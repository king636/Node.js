正则表达式：
匹配：
\d 数字
\w 字母
\s 空格(或Tab等空白符)
. 任意字符(一个)
* 任意个字符(包括0个)
+ 至少一个字符(\d+至少一个数字)
? 0或1个字符
{n} n个字符 (\d{n}匹配n个数字)
{n,m} n-m个字符(\d{n,m}匹配n-m个数字)
^　行开始^\d必须以数字开头
$  行结束\d$必须以数字结束
A|B A或B

举例：\d{3}\s+\d{3,8} 匹配 
\d{3} 3个数字
\s+ 只少一个空白符
\d{3,8}　3-8个数字

区号隔开的电话号码：021 8888

\d{3}\-\d{3,8} -要转义用\- 021-8888

写法：
var re1 = /\d{3}\-\d{3,8}/; 需要用/.../的形式
var re2 = new RegExp(/\d{3}\-\d{3,8}/);
var re3 = new RegExp('\\d{3}\\-\\d{3,8}');字符串中\都需要转义成\\

[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；

[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等；

[a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；

[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

切分字符串：
'a b   c'.split(/\s+/); // ['a', 'b', 'c'] //连续空格识别
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']//空格或,或;识别

分组:()
提取分组：exec()

var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345'],返回的是Array

对时间的匹配：
var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']

贪婪匹配
默认为贪婪匹配，0*匹配的是空字符串：
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
改为非贪婪（加个?,原理是啥？）：
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']

全局搜索：g 每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引:
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到

再举例：
//g代表全局搜索，以字符串的replace()为例
var s = '1234324-ffwfwef-mmmmj-end';
var regS = /\-/;
console.log(s.replace(regS,'+'));//1234324+ffwfwef-mmmmj-end


var regs2 = /\-/g;//全局搜索替换
console.log(s.replace(regs2,'+'));//1234324+ffwfwef+mmmmj+end

