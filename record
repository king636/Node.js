ubuntu下安装nodejs
1. 下载node-v7.6.0-linux-x64.tar.xz后提取
2. 移动到opt下:sudo mv node-v7.6.0-linux-x64 /opt/
3. 安装 npm 和 node 命令到系统命令 
sudo ln -s /opt/node-v4.4.4-linux-x64/bin/node /usr/local/bin/node 
sudo ln -s /opt/node-v4.4.4-linux-x64/bin/npm /usr/local/bin/npm

验证: node -v
输出：v7.6.0

验证: npm -v
输出：4.1.2

进入node交互模式: node
> 100+200
300

退出node, 按ctrl+c两次

node应用
~/work/nodejs下新建hello.js:
'use strict'
console.log('hello world'); --打印输出，如果是在node交互模式中，运行一句则打印结果，如上面的100+200

该目录下运行：node hello.js
输出：hello world

开启严格模式：
node --use_strict hello.js (与hello.js的收行作用一样 'use strict')

安装visual studio code
下载deb文件后提取，进入code目录下直接运行code

打开文件夹/work/nodejs，则该文件夹作为vsc的工程目录
点击hello.js 点击左边菜单中的调试，运行，提示配置launch.json，配置成如下：
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run hello.js",
            "type": "node",
            "request": "launch",
            "program": "${workspaceRoot}/hello.js",
            "stopOnEntry": false,
            "args": [],
            "cwd": "${workspaceRoot}",
            "preLaunchTask": null,
            "runtimeExecutable": null,
            "runtimeArgs": [
                "--nolazy"
            ],
            "env": {
                "NODE_ENV": "development"
            },
            "externalConsole": false,
            "sourceMaps": false,
            "outDir": null
        }
    ]
}

可看到nodejs工程目录下出现.vscode - launch.json
有了配置文件，即可使用VS Code调试JavaScript

模块和调用
hello.js就是一个模块，模块名为hello,　改写hello.js(/vsc_project/hello.js):
'use strict'
var s = 'hello';

function greet(name){
    console.log(s + ',' + name + '!');
}

module.exports = greet;//暴露函数，也可以是对象，变量，数组等

main.js(/vsc_project/main.js)中调用模块暴露的函数：
var greet = require('./hello.js');//如果只写hello，Node会依次在内置模块、全局模块和当前模块下查找hello.js
var s = 'nick';
greet(s);

注意main.js放在工程目录/vsc_project目录时launch.json需要修改　--这里launch.json只有一个，所有调试不同的js文件时就要做修改，是否有其他用法？

CommonJS规范
javascript中不同模块可能定义了相同的全局变量，造成使用和修改的冲突．
nodejs避免这种情况，原理：利用了闭包，把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。

原理理解：待深入

基本模块：nodejs内置的常用模块
1. global 全局对象，类似js的window

node交互环境中：
> global.console
Console {
  log: [Function: bound log],
  info: [Function: bound log],
  warn: [Function: bound warn],
  error: [Function: bound warn],
  dir: [Function: bound dir],
  time: [Function: bound time],
  timeEnd: [Function: bound timeEnd],
  trace: [Function: bound trace],
  assert: [Function: bound assert],
  Console: [Function: Console] }

2. process
代表当前Node.js进程
> global.process 也可查看详细信息

> process === global.process
true
> process.version
'v7.6.0'
> process.platform
'linux'
> process.arch
'x64'
> process.cwd()
'/home/nick/work/signapk'　//查看当前工作目录

test.js
// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
    console.log('nextTick callback!');　--后打印
});
console.log('nextTick was set!'); --这里先打印

判断javascript环境(是在浏览器中执行还是在Node.js中执行)
detectEnv.js:
'use strict'

if(typeof(window) === 'undefined'){
    console.log("Node.js environment");
}else{
    console.log("Browser environment");
}

内置的fs模块 -- 文件系统模块
fs提供了异步和同步的方法

jQuery中的异步方法：
$.getJSON('http://example.com/ajax',function(data){
	console.log('IO结果返回后执行...');
});

同步方法：
var data = getJSONSync('http://example.com.ajax');

fs异步读文件：
NODEJS
 -vsc_project
  -fs
   -readTextAync.js：

'use strict'

var fs = require('fs');
fs.readFile('./vsc_project/fs/sample.txt','utf-8',function(err,data){
    if(err){
        console.log(err);
    }else{
        console.log(data);
    }
})

注意：按照网上教程，这里sample.txt放在同级下，写成fs.readFile('sample.txt')时会提示找不到(sample.txt放在根目录下可以找到)

fs异步读取二进制文件
上面例子中第二个参数'utf-8'不写的时候，data返回的是Buffer对象，字节数组
	console.log(data);
        console.log('length: ' + data.length + ' bytes');

        //Buffer转换为String
        var text = data.toString('utf-8');
        console.log('Buffer to String: ' + text);

        //String转换为Buffer
        var buf = Buffer.from(text,'utf-8');
      //  console.log('String to Buffer: ' + buf);//这种写法，buf会被换成string打印
        console.log('String to Buffer: ');
        console.log('String to Buffer: ' + buf);

fs同步读取文件：
 var data = fs.readFileSync('./vsc_project/fs/sample.txt','utf-8');
 console.log(data);

fs异步写文件：
var fs = require('fs');
var data = 'nodejs aync';
//output.txt会被写到根目录下
fs.writeFile('output.txt',data,function(err){
    if(err){
        console.log(err);
    }else{
        console.log('write successfully!');
    }
});

同步写文件：
fs.writeFileSync('output.txt',data);

追加到文件尾部？：
var fs = require('fs');
var data = '\nappend to file';
//追加到文件尾部
fs.appendFile('output.txt',data,function(err){
    if(err){
        console.log(err);
    }else{
        console.log('ok');
    }
})

如果该文件不存在，则会创建并写入data


获取文件信息stat
var fs = require('fs');
fs.stat('output.txt',function(err,stat){
    if(err){
        console.log(err);
    }else{
        //是否是文件
        console.log('is file ? ' + stat.isFile());
        //是否是目录
        console.log('is directory ? ' + stat.isDirectory());
        if(stat.isFile()){
            //文件大小
            console.log('file size: ' + stat.size);
            //文件创建时间
            console.log('file birth time: ' + stat.birthtime);
            //文件修改时间
            console.log('file modify time: ' + stat.mtime);
        }
    }
})

同步获取：
var fs = require('fs');
var stat = fs.statSync('output.txt');
if(stat){
    //是否是文件
    console.log('is file ? ' + stat.isFile());
    //是否是目录
    console.log('is directory ? ' + stat.isDirectory());
    if(stat.isFile()){
        //文件大小
        console.log('file size: ' + stat.size);
        //文件创建时间
        console.log('file birth time: ' + stat.birthtime);
        //文件修改时间
        console.log('file modify time: ' + stat.mtime);
    }
}

stream流读取文件：
'use strict'

var encode = 'utf-8';
var fs = require('fs');

//打开流
var rs = fs.createReadStream('./vsc_project/fs/sampleRead.txt', encode);

//data事件即读取流事件，文件内容多的时候可能多次
rs.on('data',function(chunk){
    console.log('DATA');
    console.log(chunk);
});

//读取结束
rs.on('end',function(){
    console.log('END');
});

//比如文件名不存在，会走到这里
rs.on('error',function(err){
    console.log('ERROR' + err);
});

stream流写入文件：
'use strict'

var encode = 'utf-8';

var fs = require('fs');

var ws = fs.createWriteStream('./vsc_project/fs/sampleWriteStream.txt',encode);
ws.write('以文本形式写入流\n',encode);
ws.write('END.',encode);
ws.end();

var ws2 = fs.createWriteStream('./vsc_project/fs/sampleWriteStream2.txt',encode);
ws2.write(new Buffer('以二进制形式写入流\n',encode));
ws2.write(new Buffer('END.',encode));
ws2.end();

pipe将读取流与写入流串起来：
'use strict'

var encode = 'utf-8';
var rootDir = './vsc_project/fs/'

var fs = require('fs');
var rs = fs.createReadStream(rootDir + 'sampleRead.txt', encode);

var ws = fs.createWriteStream(rootDir + 'pipeStream.txt', encode);

rs.pipe(ws);

pipe后不关闭：
'use strict'

var encode = 'utf-8';
var rootDir = './vsc_project/fs/'

var fs = require('fs');
var rs = fs.createReadStream(rootDir + 'sampleRead.txt', encode);

var ws = fs.createWriteStream(rootDir + 'pipeStream.txt', encode);

//写完则关闭流
// rs.pipe(ws);

//不关闭ws
rs.pipe(ws,{end:false});
ws.write('\n继续写入.\n',encode);

//这句会报错，原因是流操作为异步，事实上pipe会在这之后执行，如果end那么pipe执行会报错．
//思考：如何更好的控制呢？比如pipe先执行，什么时候应该end了？
//目前合理的方法应该是分开执行
// ws.end();

HTTP模块:
创建server



